FILE 2: crypto.cpp  
#include "crypto.h"  #include <cryptopp/filters.h> #include <cryptopp/modes.h> #include <cryptopp/secblock.h>  namespace Crypto {  
    // --------------- 
    // Cryptography 
    // ---------------  
    Bytes sha256_hash(const Bytes& data) { CryptoPP::SHA256 hash; Bytes digest(hash.DigestSize()); hash.CalculateDigest(digest.data(), data.data(), data.size()); return digest; }  Bytes ripemd160_hash(const Bytes& data) { CryptoPP::RIPEMD160 hash; Bytes digest(hash.DigestSize()); hash.CalculateDigest(digest.data(), data.data(), data.size()); return digest; }  Bytes aes_encrypt(const Bytes& plaintext, const Bytes& key) { Bytes ciphertext; CryptoPP::SecByteBlock key_block(key.data(), key.size()); CryptoPP::ECB_Mode<CryptoPP::AES>::Encryption encryptor(key_block, key_block.size()); CryptoPP::ArraySink sink(ciphertext.data(), ciphertext.size()); CryptoPP::ArraySource source(plaintext.data(), plaintext.size(), true, new CryptoPP::StreamTransformationFilter(encryptor, new CryptoPP::Redirector(sink))); return ciphertext; }  Bytes aes_decrypt(const Bytes& ciphertext, const Bytes& key) { Bytes plaintext; CryptoPP::SecByteBlock key_block(key.data(), key.size()); CryptoPP::ECB_Mode<CryptoPP::AES>::Decryption decryptor(key_block, key_block.size()); CryptoPP::ArraySink sink(plaintext.data(), plaintext.size()); CryptoPP::ArraySource source(ciphertext.data(), ciphertext.size(), true, new CryptoPP::StreamTransformationFilter(decryptor, new CryptoPP::Redirector(sink))); return plaintext; }  Bytes generate_aes_key(const Bytes& seed) { Bytes key(CryptoPP::AES::DEFAULT_KEYLENGTH); CryptoPP::SHA256().CalculateDigest(key.data(), seed.data(), seed.size()); return key; }  Bytes generate_private_key(const Bytes& seed) { Bytes private_key(CryptoPP::ECP::PrivateKey::DEFAULT_KEYLENGTH); CryptoPP::SHA256().CalculateDigest(private_key.data(), seed.data(), seed.size()); return private_key; }  Bytes ecdsa_sign(const Bytes& data, const Bytes& private_key) { Bytes signature(CryptoPP::ECDSA<CryptoPP::ECP, CryptoPP::SHA256>::SIGNATURE_LENGTH); CryptoPP::ECDSA<CryptoPP::ECP, CryptoPP::SHA256>::Signer signer; signer.AccessKey().Load(private_key.data(), private_key.size()); signer.SignMessage(data.data(), data.size(), signature.data()); return signature; }  Bytes ecdsa_verify(const Bytes& data, const Bytes& signature, const Bytes& public_key) { CryptoPP::ECDSA<CryptoPP::ECP, CryptoPP::SHA256>::Verifier verifier; verifier.AccessKey().Load(public_key.data(), public_key.size()); return verifier.VerifyMessage(data.data(), data.size(), signature.data(), signature.size()); }  
    // --------------- 
    // Monero/Zcash 
    // ---------------  
    std::string generate_monero_address(const Bytes& public_key) { Bytes hash = ripemd160_hash(public_key); return std::string("4") + std::string(hash.begin(), hash.end()); }  std::string generate_zcash_address(const Bytes& public_key) { Bytes hash = sha256_hash(public_key); return std::string("t1") + std::string(hash.begin(), hash.end()); }  Bytes generate_monero_tx_data(const Bytes& sender_public_key, const Bytes& recipient_public_key, uint64_t amount) { Bytes data; data.insert(data.end(), sender_public_key.begin(), sender_public_key.end()); data.insert(data.end(), recipient_public_key.begin(), recipient_public_key.end()); data.push_back(static_cast<Byte>(amount & 0xFF)); data.push_back(static_cast<Byte>((amount >> 8) & 0xFF)); data.push_back(static_cast<Byte>((amount >> 16) & 0xFF)); data.push_back(static_cast<Byte>((amount >> 24) & 0xFF)); return data; }  Bytes generate_zcash_tx_data(const Bytes& sender_public_key, const Bytes& recipient_public_key, uint64_t amount) { Bytes data; data.insert(data.end(), sender_public_key.begin(), sender_public_key.end()); data.insert(data.end(), recipient_public_key.begin(), recipient_public_key.end()); data.push_back(static_cast<Byte>(amount & 0xFF)); data.push_back(static_cast<Byte>((amount >> 8) & 0xFF)); data.push_back(static_cast<Byte>((amount >> 16) & 0xFF)); data.push_back(static_cast<Byte>((amount >> 24) & 0xFF)); data.push_back(static_cast<Byte>((amount >> 32) & 0xFF)); data.push_back(static_cast<Byte>((amount >> 40) & 0xFF)); data.push_back(static_cast<Byte>((amount >> 48) & 0xFF)); data.push_back(static_cast<Byte>((amount >> 56) & 0xFF)); return data; }  Bytes generate_monero_signature(const Bytes& tx_data, const Bytes& private_key) { Bytes signature = ecdsa_sign(tx_data, private_key); return signature; }  Bytes generate_zcash_signature(const Bytes& tx_data, const Bytes& private_key) { Bytes signature = ecdsa_sign(tx_data, private_key); return signature; }  } 
    // 
    namespace Crypto